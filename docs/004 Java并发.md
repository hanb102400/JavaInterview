##  线程

### 并行和并发的区别

并发和并行是相对于资源的概念。

并行：同时运行多个任务，互不干涉。

并发 ：在同一个资源上，“同时”运行多个任务。这里的同时不一定是一个时间，也可以是交替运行。



### 同步和异步的区别

同步：运行任务后，等待返回结果才会继续运行。

异步 ：运行任务后，不必等待返回结果继续运行。

1）同步和异步最大的区别就在于。一个需要等待，一个不需要等待。

2）同步可以避免出现死锁，读脏数据的发生，一般共享某一资源的时候用，如果每个人都有修改权限，同时修改一个文件，有可能使一个人读取另一个人已经删除的内容，就会出错，同步就会按顺序来修改。



### 线程和进程的区别

进程：是操作系统进行资源分配的最小单位，每个进程有着独立的代码和资源空间。

线程：是CPU进行调度的最小单位，是由进程创建的顺序执行流，共享进程的代码和资源空间。

区别是：

1. 线程是进程的一部分，一个进程中可以拥有多个线程。

2. 进程之间不共享内存资源，线程之间可以共享内存资源。

3. 线程创建需要资源少，进程创建开销较大。

   > 创建进程进行资源分配的代价要大得多，所以多线程在高并发环境中效率高。

4. 线程上下文的切换效率高，进程间切换开销较大。

   > 进程切换需要涉及CPU 环境的重新设置，线程切换仅需要保存和设置少量的寄存器内容。



###  创建线程
创建线程有以下几种方法：

- 实现Runnable接口，重写run函数  
- 继承Thread类，重写run函数 
- 实现Callable接口，重写call函数
- 使用线程池创建运行线程，`ThreadService.execute()`或者`ThreadService.submit()`方法

### 线程状态

线程有一下下6种状态
- 新建**(NEW)**
- 就绪或运行**(RUNNABLE)**
- 阻塞**(BLOCKED)**
- 等待**(WAITING)**
- 计时等待**(TIMED_WAITING)**
- 终止**(TERMINATED)**

![xxx](thread1-1590937767543.png)



##  无锁

### ThreadLocal的原理

概念:
使用`TheadLocal`维持线程封闭。`TheadLocal`提供`get`和`set`方法为变量在每个线程中存有一份副本。

实现机制：
当使用 `ThreadLocal `维护变量时，其为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不会影响其他线程对应的副本。



每个线程内部都会维护一个类似 `HashMap` 的对象，称为 `ThreadLocalMap`，里边会包含若干了 Entry（K-V 键值对），相应的线程被称为这些 `Entry` 的属主线程；`Entry `的 Key` 是一个 `ThreadLocal` 实例，`Value` 是一个线程特有对象。Entry 的作用即是：为其属主线程建立起一个 `ThreadLocal` 实例与一个线程特有对象之间的对应关系；`Entry` 对 `Key` 的引用是弱引用；`Entry `对` Value` 的引用是强引用。





### Volatile关键字的原理

作用

- 保证内存可见性 ：多线程操作的时候，一个线程修改了一个变量的值 ，其他线程能立即看到修改后的值。
- 防止指令重排序：即程序指令的执行顺序按照代码的顺序执行（处理器为了提高代码的执行效率可能会对代码进行重排序）

原理：

- lock前缀指令：使用volitate修饰的变量在汇编阶段，会多出一条lock前缀指令
- 实现内存屏障：它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成
- 强制刷新缓存：它会强制将对缓存的修改操作立即写入主存
- 确保缓存失效：写操作时，它会导致其他CPU里缓存了该内存地址的数据无效

> 优点：
> 1. 可以解决线程间的内存可见性问题
> 缺点：
> 1. 不能保证操作的原子性



### Atomic 关键字

可以使基本数据类型以原子的方式实现自增自减等操作。





##  锁

###  死锁

所谓死锁：是指多个进程在运行过程中因争夺资源而造成的一种僵局。

产生的原因：竞争资源，当系统中多个进程使用共享资源，并且资源不足以满足需要，会引起进程对资源的竞争而产生死锁。进程间推进的顺序非法：请求和释放资源的顺序不当，也同样会导致产生进程死锁

- 互斥条件：一个资源每次只能被一个线程使用；（进程独占资源）
- 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放；（进程因请求资源而阻塞时，对已获得的资源保持不放） 
- 不剥夺条件：进程已经获得的资源，在未使用完之前，不能强行剥夺；（进程已获得的资源，在末使用完之前，不能强行剥夺）
- 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。若干进程之间形成一种头尾相接的循环等待资源关系）







### 什么是自旋锁？



### 什么是乐观锁和悲观锁？



### synchronized 关键字实现原理

synchronized可以限制方法同步和代码块同步.

**同步方法：**

1）对于同步代码方法，在JVM字节码层面并没有任何特别的指令来实现被synchronized修饰的方法，而是在Class文件的方法表中将该方法的access_flags字段中的synchronized标志位设置成1，表示该方法是同步方法

2）获取锁：当某个线程要访问某个方法的时候，使用调用该方法的对象(普通方法同步)或该方法所属的Class在JVM的内部对象表示Class做为监视器锁(静态方法同步，全局锁)，这时如果其他线程来请求执行方法，会因为无法获得监视器锁而被阻断住。值得注意的是，如果在方法执行过程中，发生了异常，并且方法内部并没有处理该异常，那么在异常被抛到方法外面之前监视器锁会被自动释放

**同步代码块：**

1）对于同步代码块，JVM采用monitorenter、monitorexit两个指令来实现同步。monitorenter指令插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置，JVM需要保证每一个monitorenter都有一个monitorexit与之相对应，这样就保证了执行monitorexit指令的线程是monitor监视器的所有者。

2）获取锁：在执行monitorenter指令时，把锁的计数器加1，

3）释放锁：在执行monitorexit指令时，锁计数器减1，当计数器为0时，锁就会被释放。

4）如果获取对象锁失败，那当前线程就要进入等待状态，直到对象锁被另外一个线程释放为止。



### CAS原理

CAS即：比较和交换（Conmpare And Swap）字面意思:”比较并交换“，是一种乐观锁，通过unsafe类的compareAndSwap方法实现的.

CAS操作包含三个操作数：内存位置（V），预期原值（A）和新值（B），如果内存位置的值与预期原值相匹配，那么处理器将会自动将该位置值更新为新值。否则，处理器不做任何操作。

Lock 相关类等底层就是用 CAS实现的，在一定程度上性能比 synchronized 更高.

一个 CAS 涉及到以下操作：

> 我们假设内存中的原数据V，旧的预期值A，需要修改的新值B。
>
> 1. 比较 A 与 V 是否相等。（比较）
> 2. 如果比较相等，将 B 写入 V。（交换）
> 3. 返回操作是否成功。

 CAS 其实是一个乐观锁,  当多个线程同时对某个资源进行CAS操作，只能有一个线程操作成功，但是并不会阻塞其他线程,其他线程只会收到操作失败的信号。



### LockSupport工具

### AQS的原理

1）AQS是一个JAVA抽象类，**AbstractQueuedSynchronizer** 。

2）内部会保存一个状态变量state，通过CAS修改该变量的值，修改成功的线程表示获取到该锁，没有修改成功，或者发现状态state已经是加锁状态，则通过一个Waiter对象封装线程，添加到等待队列中，并挂起等待被唤醒

> 例如：ConcurrentLock底层基于Locksupport和AQS实现。







### ReentrantReadWriteLock读写锁原理



## 线程通信

###  java同步机制

Java同步机制有以下几种方式：

**（1）volatile关键字 **

volatile关键字，可以解决线程间的内存可见性问题，但是不能保证操作的原子性。


**（2）synchronized关键字:  ** 

synchronized内置锁，是一种独占锁，阻塞锁，不可重入锁，悲观锁。

可以进行方法加锁或者代码块加锁。

**（3）ReentrantLock锁**：

ReentrantLock锁，是一种自旋锁，非阻塞锁，可重入锁，乐观锁。



> 在try语句内加锁，在final语句内释放锁。

**CountDownLatch**（倒计时门闩）

**CyclicBarrier**（栅栏）

**Semaphore**（信号量）

**Phaser**

**Exchanger**



### JAVA线程通信有哪些方式

java线程通信，有以下几种该方式进行线程切换，控制共享变量的访问顺序：

**（1）Object类：**`wait()`，`notify()`，`notifyAll()`方法

  >1.  `wait()`，`notify()`，`notifyAll()`必须在`synchronized`关键字内使用
  >2.  `wait()`方法会释放对象锁，并进入阻塞
  >3.  `notify()`，`notifyAll()`方法，会随机唤醒阻塞的线程

**（2）Condition类：** await()，signal()方法

  >1. `await()`，`signal()`方法必须搭配Lock锁使用
  >2. `await()`方法，执行后当前线程挂起，并加入到阻塞队列
  >3. `signal()`方法，执行后从阻塞队列种取出一个线程并唤醒

**ountDownLatch（倒计时门闩）**

**CyclicBarrier（栅栏）**

**Semaphore（信号量）**





### Condition接口及其实现原理？







### 如何调用 wait（）方法？使用 if 块还是循环？为什么？**

wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。

wait()，notify（）和notifyall（）方法是java.lang.Object类为线程提供的用于实现线程间通信的同步控制方法。等待或者唤醒








### Fork/Join框架的理解?

---



**锁的优化策略**

① 读写分别加锁，读写锁

② 分段加锁

③ 减少锁持有的时间

④ 多个线程尽量以相同的顺序去获取资源



问题:

1. 写个死锁，再写个怎么解决这死锁





## 线程池

### 线程池的了解？

答：java.util.concurrent.ThreadPoolExecutor 类就是一个线程池。客户端调用 ThreadPoolExecutor.submit(Runnable task) 提交任务，线程池内部维护的工作者线程的数量就是该线程池的线程池大小，有 3 种形态：

1）当前线程池大小 ：表示线程池中实际工作者线程的数量；

2）最大线程池大小 （maxinumPoolSize）：表示线程池中允许存在的工作者线程的数量上限；

3）核心线程大小 （corePoolSize ）：表示一个不大于最大线程池大小的工作者线程数量上限。如果运行的线程少于 corePoolSize，则 Executor 始终首选添加新的线程，而不进行排队；如果运行的线程等于或者多于 corePoolSize，则 Executor 始终首选将请求加入队列，而不是添加新线程；如果无法将请求加入队列，即队列已经满了，则创建新的线程，除非创建此线程超出 maxinumPoolSize， 在这种情况下，任务将被拒绝。

```java
 public ThreadPoolExecutor(
     int corePoolSize,
     int maximumPoolSize,
     long keepAliveTime,
     TimeUnit unit, 
     BlockingQueue<Runnable> workQueue,
     ThreadFactory threadFactory,
     RejectedExecutionHandler handler
 );
```

参数：

- corePoolSize：核心线程大小 
- maximumPoolSize：最大线程池大小
- keepAliveTime：线程空闲存活时间
- unit：线程空闲存活时间单位
- workQueue：工作队列
- threadFactory：
- handler：





线程创建规则：

- 如果当前线程池中的＂线程数目＜corePoolSize＂，就会创建一个新的线程去执行这个任务；
- 如果当前线程池中的＂线程数目>=corePoolSize＂，会尝试将任务添加到任务缓存队列当中
- 如果当前线程池中的＂缓存队列已满＂，则会尝试创建新的线程去执行这个任务；
- 如果当前线程池中的＂线程数目>=maximumPoolSize＂，则会采取任务拒绝策略进行处理；
- 如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。



### 线程池优化



**11. 线程池**

根据系统自身的环境情况，有效的限制执行线程的数量，使得运行效果达到最佳。线程主要是通过控制执行的线程的数量，超出数量的线程排队等候，等待有任务执行完毕，再从队列最前面取出任务执行

**





## 问题：



**Runnable接口和Callable接口的区别?**

区别：

- Callable需要实现call方法，而Runnable需要实现run方法
- run方法无返回值，call方法返回Future对象 



**线程start()方法和run()方法的区别?**

区别：

- run()方法只是类的一个普通方法，直接调用不会创建线程
- start()方法会调用CPU底层方法，创建一个线程执行 



**sleep( ) 和wait( )的区别？**

sleep 方法：

- sleep()是Thread 类的静态方法，有限期阻塞。
- sleep()设置睡眠时间，到期后会自动解除阻塞进入可运行状态。
- sleep() 不会释放线程的对象锁。

wait 方法：

- wait( )是 Object 的方法，无限期阻塞。
- wait( )必须在 synchronized 关键字内使用。
- wait() 如果设置时间，到期后会自动释放线程锁。
- wait()  如果没有设置时间，需要其他线程调用notify() 或notifyAll()方法唤醒，并尝试重新获取锁。只有重新占用互斥锁之后才会进入可运行状态。



 **sleep( ) 和yield( )的区别？**

sleep 方法：

- sleep()执行后，线程进入阻塞BLOCKED状态。
- sleep()方法会抛出InterruptedException异常
- sleep()执行进入阻塞，一定会让出线程运行机会。

yield方法：

- yield( )执行后，线程进入就绪Runnable状态
- yield( )方法不会抛出异常。
- yield( )方法执行后，只给相同或者更高优先级的线程运行机会（不一定会确保让出）。



**wait( )和await（）的区别：** 

1. `wait`()是 `Object` 的方法，需要调用`notify()` 或`notifyAll()`方法唤醒。

2. `await()`是`Condition`的方法，需要调用`signal()`方法来唤醒。



**park()和wait()的区别** 

LockSupport中的park() 和 unpark() 的作用分别是阻塞线程和解除阻塞线程.



**用三个线程按顺序循环打印abc三个字母，比如abcabcabc?**

说明：

使用一个共享变量 x ，判断 x % 3 的次数。 每次加锁并唤醒所有线程，如果打印线程抢到锁，满足条件则进行打印处理，不满足条件则继续等待并释放锁。

实现：

1）使用Object类的wait() 和notify() 方法

2）使用Condition类的await() 和signal();   

3）使用Semaphore



**synchronized锁和ReentrantLock锁的区别**





**如何实现一个生产者-消费者模型?**




**如何避免死锁**

答：指定获取锁的顺序，按顺序获取锁。

举例如下：

比如某个线程只有获得 A 锁和 B 锁才能对某资源进行操作，在多线程条件下，如何避免死锁？获得锁的顺序是一定的，比如规定，只有获得 A 锁的线程才有资格获取 B 锁，按顺序获取锁就可以避免死锁！！！



**什么是多线程环境下的伪共享（falsesharing）？** 

伪共享是多线程系统（每个处理器有自己的局部缓存）中一个众所周知的性能问题。缓存系统中是以缓存行（cache line）为单位存储的。缓存行是2的整数幂个连续字节，一般为32-256个字节。最常见的缓存行大小是64个字节。当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。 



**有什么方法可以解决多线程下数据共享的问题?**

1. Volatile内存屏障，保证可见性和防止指令重排
2. atomic包，保证操作的原子性
3. 线程封闭， 使用ThreaLocal维护数据副本
4. 使用锁，synchronized和lock

**线程同步与阻塞的关系？同步一定阻塞吗？阻塞一定同步吗？**

线程同步与否 跟 阻塞非阻塞没关系。同步是个过程，阻塞是线程的一种状态。

多个线程操作共享变量时可能会出现竞争。这时需要同步来防止两个以上的线程同时进入临界区内，在这个过程中后进入临界区的线程将阻塞，等待先进入的线程走出临界区。

