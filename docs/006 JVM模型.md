











## JVM内存模型



------

### 请介绍一下JVM内存模型

1）程序计数器：每个线程独有，是当前线程执行的字节码的行指示器。

2）栈(stack)：每个线程独有，每个线程包含一个栈区，栈中保存一些局部变量等。

> 包括
>
> - 虚拟机栈
>
> - 本地方法栈

3）堆(heap)：所有线程共享，存放对象实例以及数组，Java堆是GC的主要区域。

> - 包括

4)  元数据区: 所有线程共享。方法区包含所有的类信息和静态变量,常量等.

> - 

5)  直接内存 

>1.8版本后修改:
>
>常量池 : 常量池移动到堆中进行管理
>
>方法区: 移到 元数据区



### Java 中堆和栈有什么区别

JVM 中堆和栈属于不同的内存区域，使用目的也不同。

1）栈：常用于保存方法帧和局部变量，每个线程独立。

2）堆：用来分配象，属于线程共享。

栈通常都比堆小，属于单个线程独有的,  不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。







## GC垃圾回收

### JVM新生代，老年代，持久代，都存储哪些东西？

持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。所有新生成的对象首先都是放在年轻代的，年老代中存放的都是一些生命周期较长的对象。



#### GC 是什么时候开始？

答：GC 经常发生的区域是堆区，堆区还可以细分为新生代、老年代，新生代还分为一个 Eden 区和两个 Survivor 区。

对象优先在 Eden 中分配，当 Eden 中没有足够空间时，虚拟机将发生一次 Minor GC，因为 Java 大多数对象都是朝生夕灭，所以 Minor GC 非常频繁，而且速度也很快；Full GC，发生在老年代的 GC，当老年代没有足够的空间时即发生 Full GC，发生 Full GC 一般都会有一次 Minor GC。大对象直接进入老年代，如很长的字符串数组，虚拟机提供一个；XX:PretenureSizeThreadhold 参数，令大于这个参数值的对象直接在老年代中分配，避免在 Eden 区和两个 Survivor 区发生大量的内存拷贝；

发生 Minor GC 时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则进行一次 Full GC，如果小于，则查看 HandlePromotionFailure 设置是否允许担保失败，如果允许，那只会进行一次 Minor GC，如果不允许，则改为进行一次 Full GC。



### Minor GC 和 Full GC的区别

- Minor GC：发生在新生代上，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。

- Full GC：发生在老年代上，老年代对象和新生代的相反，其存活时间长，因此 Full GC 很少执行，而且执行速度会比 Minor GC 慢很多。


**2.GC算法（什么样的对象算是可回收对象，可达性分析），CMS收集器**

jvm是如何判断一个对象已经变成了可回收的“垃圾”，一般是两个方法：引用记数法和根搜索算法。引用记数法没办法解决循环引用的问题，所以用根搜索。从一系列的”GC Roots“对象开始向下搜索，搜索走过的路径称为引用链。当一个对象到”GC Roots“之间没有引用链时，被称为引用不可达。引用不可到的对象被认为是可回收的对象。

```
         几种垃圾收集器：
         1，Serial New/Serial Old(串行)，
         2，Parrallel New (并行)，
         3，Parrallel Scavenge，4，
         Parrallel Old，
         5，CMS（CMS收集器是一个以获得最短回收停顿时间为目标的收集器，它是一种并发收集器，采用的是Mark-sweep算法。）
         6，G1（是一款并行与并发收集器，并且可建立可预测的停顿时间模型，整体上是基于标记清理，局部采用复制）
```





### 内存溢出和内存泄漏的区别

答：

概念：

1）内存溢出：程序申请内存时，没有足够的内存。抛出OutOfMemoryError异常；

2）内存泄漏，是指垃圾对象没有被回收。垃圾对象无法回收，导致堆积。可以使用memory analyzer工具查看泄漏。

内存泄漏是指对象可达，但是没用了。即本该被 GC 回收的对象并没有被回收；内存泄露是导致内存溢出的原因之一；内存泄露积累起来将导致内存溢出。内存泄漏的原因分析：

长生命周期的对象引用短生命周期的对象；没有将无用对象置为 null。小结：本小节涉及到 JVM 虚拟机，包括对内存的管理等知识，相对较深。除了以上问题，面试官会继续问你一些比较深的问题，可能也是为了看看你的极限在哪里吧。比如：内存调优、内存管理，是否遇到过内存泄漏的实际案例、是否真正关心过内存等。





### Java异常

栈溢出:	StackOverflowError异常.

```
public class StackOverflow
{
    public static void main(String[] args)
    {
        new StackOverflow().test();
    }

    public void test()
    {
        test();
    }

}
```



内存溢出:   OutOfMemoryError异常.

```
public class OutofHeap
{
    public static void main(String[] args)
    {
        ArrayList list=new ArrayList();
        while(true)
        {
            list.add(new OutofHeap());
        }
    }
}
```









**java 中 WeakReference 与 SoftReference的区别？** 

区别

1）SoftReference（软引用） 会尽可能长的保留引用直到 JVM 内存不足时才会被回收(虚拟机保证), 这一特性使得SoftReference 非常适合缓存应用 

2）WeakReference（弱引用）一旦失去最后一个强引用，就会被 GC 回收，回收几率高。



问题

**1. 线上发送频繁full gc如何处理? CPU 使用率过高怎么办?如何定位问题?如何解决说一下解决思路和处理方法**



**2. 解释 Java 堆空间及 GC？**

当通过 Java 命令启动
Java 进程的时候，会为它分配内存。内存的一部分用于创建堆空间，当程序中创建对象的时候，就从对空间中分配内存。GC 是 JVM 内部的一个进程，回收无效对象的内存用于将来的分配。





## 类加载机制

### JVM如何加载一个类的过程



### 类的加载周期

**加载＝》验证＝》准备＝》解析＝》初始化＝》使用＝》卸载**  

![images/jvm1.1.png](jvm1.1.png)



类加载过程：

1）加载、

2）验证（验证阶段作用是保证Class文件的字节流包含的信息符合JVM规范，不会给JVM造成危害）

3）准备（准备阶段为变量分配内存并设置类变量的初始化）、

4）解析（解析过程是将常量池内的符号引用替换成直接引用）

5）初始化

6）使用

7）卸载 



### 类加载机制,  都有哪些类加载器，这些类加载器都加载哪些文件?





### 双亲委托加载原理，为什么要双亲委托加载，

**双亲委托加载**

User  Classloader (自定义加载器) -> 

Applicaiton  Classloader（classpath应用程序类） -> 

Extension  Classloader （lib/ext目录类）-> 

Bootstrap classloader （lib目录类）

1）先检查需要加载的类是否已经被加载，如果没有被加载，则委托父加载器加载，父类继续检查，尝试请父类加载。

2）如果走到顶层发现类没有被加载过，那么会从顶层开始往下逐层尝试加载.



### 什么场景下需要打破双亲委托加载？如何打破双亲委托加载？

例如：tomcat，热加载

继承ClassLoader类，还要重写loadClass和findClass方法 ，将委托parent加载器加载 改为优先自行加载 ，然后委托parent加载器加载





### 双亲委派模型中有哪些方法

**双亲委派模型中方法：**双亲委派是指如果一个类收到了类加载的请求，不会自己先尝试加载，先找父类加载器去完成。当顶层启动类加载器表示无法加载这个类的时候，子类才会尝试自己去加载。当回到最开的发起者加载器还无法加载时，并不会向下找，而是抛出ClassNotFound异常。

方法：启动（Bootstrap）类加载器，标准扩展（Extension）类加载器，应用程序类加载器（Application ），上下文(Custom)类加载器。意义是防止内存中出现多份同样的字节码 。



### Tomcat中的ClassLoader怎么做的？



### classforName("java.lang.String")和String classgetClassLoader() LoadClass("java.lang.String") 什么区别啊?





### 知道osgi吗? 他是如何实现的???



---

### 请问你做过哪些JVM优化?使用什么方法达到什么效果???





### 生产环境如何定位内存溢出？



